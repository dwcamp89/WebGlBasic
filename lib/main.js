// Generated by CoffeeScript 1.9.0
(function() {
  require(['glMatrix-0.9.5.min', 'webgl-utils', 'WebGlConstants', 'shader'], function(glMatrix, webGlUtils, webGlConstants, shader) {
    var animate, cubeVertexColorBuffer, cubeVertexIndexBuffer, cubeVertexPositionBuffer, degToRad, drawScene, fragmentShader, getShader, gl, initBuffers, initPrograms, initWebGL, lastTime, mvMatrix, mvMatrixStack, mvPopMatrix, mvPushMatrix, pMatrix, pyramidVertexColorBuffer, pyramidVertexPositionBuffer, rCube, rPyramid, rSquare, rTri, setMatrixUniforms, shaderProgram, squareVertexColorBuffer, squareVertexPositionBuffer, start, tick, triangleVertexColorBuffer, triangleVertexPositionBuffer, vertexShader;
    gl = null;
    mvMatrix = null;
    pMatrix = null;
    mvMatrixStack = [];
    triangleVertexPositionBuffer = null;
    triangleVertexColorBuffer = null;
    rTri = null;
    squareVertexPositionBuffer = null;
    squareVertexColorBuffer = null;
    rSquare = null;
    pyramidVertexPositionBuffer = null;
    pyramidVertexColorBuffer = null;
    rPyramid = 0;
    cubeVertexPositionBuffer = null;
    cubeVertexColorBuffer = null;
    cubeVertexIndexBuffer = null;
    rCube = 0;
    shaderProgram = null;
    vertexShader = null;
    fragmentShader = null;
    mvPushMatrix = function() {
      var copy;
      copy = mat4.create();
      mat4.set(mvMatrix, copy);
      return mvMatrixStack.push(copy);
    };
    mvPopMatrix = function() {
      if (mvMatrixStack.size === 0) {
        throw "Invalid Pop Matrix";
      }
      return mvMatrix = mvMatrixStack.pop();
    };
    degToRad = function(degrees) {
      return degrees * Math.PI / 180.0;
    };
    initWebGL = function(canvas) {
      var error;
      try {
        gl = canvas.getContext(webGlConstants.WEB_GL_CONTEXT_NAME);
        gl = gl != null ? gl : canvas.getContext(webGlConstants.EXPERIMENTAL_WEB_GL_CONTEXT_NAME);
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (_error) {
        error = _error;
        console.log('error initializing webgl');
        console.log(e.message);
      }
      if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        gl = null;
      }
      return gl;
    };
    getShader = function(shaderObj) {
      var newShader;
      newShader = null;
      if (shaderObj.type === "FRAGMENT") {
        newShader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderObj.type === "VERTEX") {
        newShader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }
      gl.shaderSource(newShader, shaderObj.src);
      gl.compileShader(newShader);
      if (!gl.getShaderParameter(newShader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(newShader));
        console.log(gl.getShaderInfoLog(newShader));
        return null;
      }
      return newShader;
    };
    initPrograms = function() {
      fragmentShader = getShader(shader.fragment);
      vertexShader = getShader(shader.vertex);
      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, fragmentShader);
      gl.attachShader(shaderProgram, vertexShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.log(webGlConstants.ERROR_MESSAGES.UNABLE_TO_INITIALIZE_SHADERS);
        alert(webGlConstants.ERROR_MESSAGES.UNABLE_TO_INITIALIZE_SHADERS);
      }
      gl.useProgram(shaderProgram);
      shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
      shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
      gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
      return shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    };
    initBuffers = function() {
      var colorList, colors, j, unpackedColors, vertices, _i, _j, _len, _len1, _ref;
      pyramidVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
      vertices = [0.0, 1.0, 0.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      pyramidVertexPositionBuffer.itemSize = 3;
      pyramidVertexPositionBuffer.numberOfItems = 12;
      pyramidVertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
      colors = [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      pyramidVertexColorBuffer.itemSize = 4;
      pyramidVertexColorBuffer.numberOfItems = 12;
      cubeVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      vertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      cubeVertexPositionBuffer.itemSize = 3;
      cubeVertexPositionBuffer.numberOfItems = 24;
      cubeVertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
      colors = [[1.0, 0.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [1.0, 0.5, 0.5, 1.0], [1.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0]];
      unpackedColors = [];
      for (_i = 0, _len = colors.length; _i < _len; _i++) {
        colorList = colors[_i];
        _ref = [0, 1, 2, 3];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          j = _ref[_j];
          unpackedColors = unpackedColors.concat(colorList);
        }
      }
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
      cubeVertexColorBuffer.itemSize = 4;
      cubeVertexColorBuffer.numberOfItems = 24;
      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      vertices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertices), gl.STATIC_DRAW);
      cubeVertexIndexBuffer.itemSize = 3;
      return cubeVertexIndexBuffer.numberOfItems = 36;
    };
    setMatrixUniforms = function() {
      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      return gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    };
    drawScene = function() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
      mat4.identity(mvMatrix);
      mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
      mvPushMatrix();
      mat4.rotate(mvMatrix, degToRad(rPyramid), [1, 0, 0]);
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pyramidVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      setMatrixUniforms();
      gl.drawArrays(gl.TRIANGLES, 0, pyramidVertexPositionBuffer.numberOfItems);
      mvPopMatrix();
      mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
      mvPushMatrix();
      mat4.rotate(mvMatrix, degToRad(rCube), [1, 1, 1]);
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      setMatrixUniforms();
      gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
      return mvPopMatrix();
    };
    lastTime = 0;
    animate = function() {
      var elapsed, timeNow;
      timeNow = new Date().getTime();
      if (lastTime !== 0) {
        elapsed = timeNow - lastTime;
        rPyramid += 90 * elapsed / 1000.0;
        rCube += 90 * elapsed / 1000.0;
      }
      return lastTime = timeNow;
    };
    tick = function() {
      requestAnimFrame(tick);
      drawScene();
      return animate();
    };
    start = function() {
      var canvas;
      mvMatrix = mat4.create();
      pMatrix = mat4.create();
      canvas = document.getElementById(webGlConstants.CANVAS_ID);
      gl = initWebGL(canvas);
      initPrograms();
      initBuffers();
      if (gl) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      }
      return tick();
    };
    return start();
  });

}).call(this);
