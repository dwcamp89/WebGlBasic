// Generated by CoffeeScript 1.9.0
(function() {
  require(['glMatrix-0.9.5.min', 'webgl-utils', 'WebGlConstants', 'gl', 'shaderProgram'], function(glMatrix, webGlUtils, webGlConstants, gl, shaderProgram) {
    var animate, cubeVertexColorBuffer, cubeVertexIndexBuffer, cubeVertexPositionBuffer, degToRad, drawScene, initBuffers, lastTime, mvMatrix, mvMatrixStack, mvPopMatrix, mvPushMatrix, pMatrix, pyramidVertexColorBuffer, pyramidVertexPositionBuffer, rCube, rPyramid, setMatrixUniforms, start, tick;
    mvMatrix = null;
    pMatrix = null;
    mvMatrixStack = [];
    pyramidVertexPositionBuffer = null;
    pyramidVertexColorBuffer = null;
    rPyramid = 0;
    cubeVertexPositionBuffer = null;
    cubeVertexColorBuffer = null;
    cubeVertexIndexBuffer = null;
    rCube = 0;
    mvPushMatrix = function() {
      var copy;
      copy = mat4.create();
      mat4.set(mvMatrix, copy);
      return mvMatrixStack.push(copy);
    };
    mvPopMatrix = function() {
      if (mvMatrixStack.size === 0) {
        throw "Invalid Pop Matrix";
      }
      return mvMatrix = mvMatrixStack.pop();
    };
    degToRad = function(degrees) {
      return degrees * Math.PI / 180.0;
    };
    initBuffers = function() {
      var colorList, colors, j, unpackedColors, vertices, _i, _j, _len, _len1, _ref;
      pyramidVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
      vertices = [0.0, 1.0, 0.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      pyramidVertexPositionBuffer.itemSize = 3;
      pyramidVertexPositionBuffer.numberOfItems = 12;
      pyramidVertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
      colors = [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      pyramidVertexColorBuffer.itemSize = 4;
      pyramidVertexColorBuffer.numberOfItems = 12;
      cubeVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      vertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      cubeVertexPositionBuffer.itemSize = 3;
      cubeVertexPositionBuffer.numberOfItems = 24;
      cubeVertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
      colors = [[1.0, 0.0, 0.0, 1.0], [1.0, 0.5, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [1.0, 0.5, 0.5, 1.0], [0.75, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0]];
      unpackedColors = [];
      for (_i = 0, _len = colors.length; _i < _len; _i++) {
        colorList = colors[_i];
        _ref = [0, 1, 2, 3];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          j = _ref[_j];
          unpackedColors = unpackedColors.concat(colorList);
        }
      }
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
      cubeVertexColorBuffer.itemSize = 4;
      cubeVertexColorBuffer.numberOfItems = 24;
      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      vertices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertices), gl.STATIC_DRAW);
      cubeVertexIndexBuffer.itemSize = 3;
      return cubeVertexIndexBuffer.numberOfItems = 36;
    };
    setMatrixUniforms = function() {
      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      return gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    };
    drawScene = function() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
      mat4.identity(mvMatrix);
      mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
      mvPushMatrix();
      mat4.rotate(mvMatrix, degToRad(rPyramid), [1, 0, 0]);
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pyramidVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      setMatrixUniforms();
      gl.drawArrays(gl.TRIANGLES, 0, pyramidVertexPositionBuffer.numberOfItems);
      mvPopMatrix();
      mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
      mvPushMatrix();
      mat4.rotate(mvMatrix, degToRad(rCube), [1, 1, 1]);
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      setMatrixUniforms();
      gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
      return mvPopMatrix();
    };
    lastTime = 0;
    animate = function() {
      var elapsed, timeNow;
      timeNow = new Date().getTime();
      if (lastTime !== 0) {
        elapsed = timeNow - lastTime;
        rPyramid += 90 * elapsed / 1000.0;
        rCube += 90 * elapsed / 1000.0;
      }
      return lastTime = timeNow;
    };
    tick = function() {
      requestAnimFrame(tick);
      drawScene();
      return animate();
    };
    start = function() {
      mvMatrix = mat4.create();
      pMatrix = mat4.create();
      initBuffers();
      if (gl) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      }
      return tick();
    };
    return start();
  });

}).call(this);
