// Generated by CoffeeScript 1.9.1
(function() {
  require(['glMatrix-0.9.5.min', 'webgl-utils', 'WebGlConstants', 'shader'], function(glMatrix, webGlUtils, webGlConstants, shader) {
    var drawScene, fragmentShader, getShader, gl, initBuffers, initPrograms, initWebGL, mvMatrix, pMatrix, setMatrixUniforms, shaderProgram, squareVertexPositionBuffer, start, triangleVertexPositionBuffer, vertexShader;
    mvMatrix = null;
    pMatrix = null;
    triangleVertexPositionBuffer = null;
    squareVertexPositionBuffer = null;
    shaderProgram = null;
    gl = null;
    vertexShader = null;
    fragmentShader = null;
    initWebGL = function(canvas) {
      var error;
      gl = null;
      try {
        gl = canvas.getContext(webGlConstants.WEB_GL_CONTEXT_NAME);
        gl = gl != null ? gl : canvas.getContext(webGlConstants.EXPERIMENTAL_WEB_GL_CONTEXT_NAME);
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (_error) {
        error = _error;
        console.log('error initializing webgl');
        console.log(e.message);
      }
      if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        gl = null;
      }
      return gl;
    };
    getShader = function(shaderObj) {
      var newShader;
      newShader = null;
      if (shaderObj.type === "FRAGMENT") {
        newShader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderObj.type === "VERTEX") {
        newShader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }
      gl.shaderSource(newShader, shaderObj.src);
      gl.compileShader(newShader);
      if (!gl.getShaderParameter(newShader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        console.log(gl.getShaderInfoLog(newShader));
        return null;
      }
      return newShader;
    };
    initPrograms = function() {
      fragmentShader = getShader(shader.fragment);
      vertexShader = getShader(shader.vertex);
      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, fragmentShader);
      gl.attachShader(shaderProgram, vertexShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.log(webGlConstants.ERROR_MESSAGES.UNABLE_TO_INITIALIZE_SHADERS);
        alert(webGlConstants.ERROR_MESSAGES.UNABLE_TO_INITIALIZE_SHADERS);
      }
      gl.useProgram(shaderProgram);
      shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
      return shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    };
    initBuffers = function() {
      var vertices;
      triangleVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
      vertices = [0.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      triangleVertexPositionBuffer.itemSize = 3;
      triangleVertexPositionBuffer.numberOfItems = 3;
      squareVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      squareVertexPositionBuffer.itemSize = 3;
      return squareVertexPositionBuffer.numberOfItems = 4;
    };
    setMatrixUniforms = function() {
      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      return gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    };
    drawScene = function() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
      mat4.identity(mvMatrix);
      mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
      gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      setMatrixUniforms();
      gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numberOfItems);
      mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      setMatrixUniforms();
      return gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numberOfItems);
    };
    start = function() {
      var canvas;
      mvMatrix = mat4.create();
      pMatrix = mat4.create();
      canvas = document.getElementById(webGlConstants.CANVAS_ID);
      gl = initWebGL(canvas);
      initPrograms();
      initBuffers();
      if (gl) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      }
      return drawScene();
    };
    return start();
  });

}).call(this);
