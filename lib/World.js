// Generated by CoffeeScript 1.9.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['GLContext', 'ModelViewMatrix', 'PerspectiveMatrix', 'glMatrix-0.9.5.min', 'ShaderProgramFactory'], function(glContext, mvMatrix, pMatrix, glMatrix, ShaderProgramFactory) {
    var POSITION_X_VALUE, POSITION_Y_VALUE, POSITION_Z_VALUE, TEXTURE_X_VALUE, TEXTURE_Y_VALUE, World, gl;
    POSITION_X_VALUE = 0;
    POSITION_Y_VALUE = 1;
    POSITION_Z_VALUE = 2;
    TEXTURE_X_VALUE = 3;
    TEXTURE_Y_VALUE = 4;
    gl = glContext.getSingleton();
    World = (function() {
      var handleLoadedTexture, parseVertexStringToVertex;

      function World() {
        this.setMatrixUniforms = __bind(this.setMatrixUniforms, this);
        this.render = __bind(this.render, this);
        this.isReadyToRender = __bind(this.isReadyToRender, this);
        this.pitch = 0;
        this.deltaPitch = 0;
        this.yaw = 0;
        this.deltaYaw = 0;
        this.x = 0;
        this.y = 0.4;
        this.z = 0;
        this.speed = 0;
        this.readyToRender = false;
        this.worldVertexPositionBuffer = gl.createBuffer();
        this.worldVertexTextureCoordinateBuffer = gl.createBuffer();
        this.initializeShader();
        this.texture = gl.createTexture();
        this.loadTexture();
      }

      World.prototype.initializeShader = function() {
        this.shaderProgram = ShaderProgramFactory.getInstance('texture.vert', 'texture.frag');
        this.shaderProgram.textureCoordinateAttribute = gl.getAttribLocation(this.shaderProgram.program, 'aTextureCoord');
        gl.enableVertexAttribArray(this.shaderProgram.textureCoordinateAttribute);
        this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram.program, 'aVertexPosition');
        gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
        this.shaderProgram.samplerUniform = gl.getUniformLocation(this.shaderProgram.program, 'uSampler');
        this.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram.program, 'uPMatrix');
        return this.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram.program, 'uMVMatrix');
      };

      World.prototype.loadTexture = function() {
        this.texture.image = new Image();
        this.texture.image.onload = (function(_this) {
          return function() {
            return handleLoadedTexture(_this.texture);
          };
        })(this);
        return this.texture.image.src = 'images/mud.gif';
      };

      handleLoadedTexture = function(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        return gl.bindTexture(gl.TEXTURE_2D, null);
      };

      World.prototype.loadWorld = function() {
        var getWorldRequest;
        getWorldRequest = new XMLHttpRequest();
        getWorldRequest.open('GET', 'world.txt');
        getWorldRequest.onreadystatechange = (function(_this) {
          return function() {
            if (getWorldRequest.readyState === 4) {
              return _this.handleLoadedWorld(getWorldRequest.responseText);
            }
          };
        })(this);
        return getWorldRequest.send();
      };

      World.prototype.handleLoadedWorld = function(worldVertexText) {
        var i, vertex, vertexCount, vertexPositions, vertexTextureCoordinates, worldVertexStrings, _i, _ref;
        worldVertexStrings = worldVertexText.split("\n");
        vertexCount = 0;
        vertexPositions = [];
        vertexTextureCoordinates = [];
        for (i = _i = 0, _ref = worldVertexStrings.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          vertex = parseVertexStringToVertex(worldVertexStrings[i]);
          if (vertex.length >= 5 && vertex[POSITION_X_VALUE] !== "//") {
            vertexPositions.push(parseFloat(vertex[POSITION_X_VALUE]));
            vertexPositions.push(parseFloat(vertex[POSITION_Y_VALUE]));
            vertexPositions.push(parseFloat(vertex[POSITION_Z_VALUE]));
            vertexTextureCoordinates.push(parseFloat(vertex[TEXTURE_X_VALUE]));
            vertexTextureCoordinates.push(parseFloat(vertex[TEXTURE_Y_VALUE]));
            vertexCount += 1;
          }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.worldVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions), gl.STATIC_DRAW);
        this.worldVertexPositionBuffer.itemSize = 3;
        this.worldVertexPositionBuffer.numberOfItems = vertexCount;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.worldVertexTextureCoordinateBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoordinates), gl.STATIC_DRAW);
        this.worldVertexTextureCoordinateBuffer.itemSize = 2;
        this.worldVertexTextureCoordinateBuffer.numberOfItems = vertexCount;
        this.readyToRender = true;
        return document.getElementById("loadingText").textContent = "";
      };

      parseVertexStringToVertex = function(vertexLine) {
        if (vertexLine == null) {
          return [];
        }
        return vertexLine.replace(/^\s+/, "").split(/\s+/);
      };

      World.prototype.isReadyToRender = function() {
        return this.readyToRender;
      };

      World.prototype.render = function() {
        if (!this.isReadyToRender()) {
          return;
        }
        gl.useProgram(this.shaderProgram.program);
        gl.enable(gl.DEPTH_TEST);
        mat4.rotate(mvMatrix, Math.toRadians(-this.pitch), [1, 0, 0]);
        mat4.rotate(mvMatrix, Math.toRadians(-this.yaw), [0, 1, 0]);
        mat4.translate(mvMatrix, [-this.x, -this.y, -this.z]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.uniform1i(this.shaderProgram.samplerUniform, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.worldVertexTextureCoordinateBuffer);
        gl.vertexAttribPointer(this.shaderProgram.textureCoordinateAttribute, this.worldVertexTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.worldVertexPositionBuffer);
        gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.worldVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        this.setMatrixUniforms();
        return gl.drawArrays(gl.TRIANGLES, 0, this.worldVertexPositionBuffer.numberOfItems);
      };

      World.prototype.setMatrixUniforms = function() {
        gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, pMatrix);
        return gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, mvMatrix);
      };

      World.prototype.animate = function(timeElapsed) {
        this.yaw += this.deltaYaw;
        this.pitch += this.deltaPitch;
        if (this.speed === 0) {
          return;
        }
        this.x -= (Math.sin(Math.toRadians(this.yaw))) * this.speed * timeElapsed;
        return this.z -= (Math.cos(Math.toRadians(this.yaw))) * this.speed * timeElapsed;
      };

      return World;

    })();
    return {
      getInstance: function() {
        return new World();
      }
    };
  });

}).call(this);
