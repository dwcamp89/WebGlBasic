// Generated by CoffeeScript 1.9.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['GLContext', 'ModelViewMatrix', 'PerspectiveMatrix', 'glMatrix-0.9.5.min', 'ShaderProgramFactory', 'LightFactory'], function(glContext, mvMatrix, pMatrix, glMatrix, ShaderProgramFactory, LightFactory) {
    var NUMBER_OF_LATITUDE_BANDS, NUMBER_OF_LONGITUDE_BANDS, RADIUS, Sphere, gl;
    NUMBER_OF_LATITUDE_BANDS = 30;
    NUMBER_OF_LONGITUDE_BANDS = 30;
    RADIUS = 2;
    gl = glContext.getSingleton();
    Sphere = (function() {
      var handleLoadedTexture, initializeShader, normalizeAndFlip;

      function Sphere() {
        this.setMatrixUniforms = __bind(this.setMatrixUniforms, this);
        this.setVertexAttributes = __bind(this.setVertexAttributes, this);
        this.setTexture = __bind(this.setTexture, this);
        this.setPosition = __bind(this.setPosition, this);
        this.setLightingUniforms = __bind(this.setLightingUniforms, this);
        this.render = __bind(this.render, this);
        this.x = this.y = this.z = 0;
        this.useLighting = false;
        this.ambientLight = LightFactory.getInstance('AmbientLight');
        this.directionalLight = LightFactory.getInstance('DirectionalLight');
        this.rotationMatrix = mat4.create();
        mat4.identity(this.rotationMatrix);
        this.texture = gl.createTexture();
        this.vertexPositionBuffer = gl.createBuffer();
        this.vertexTextureCoordinateBuffer = gl.createBuffer();
        this.vertexNormalBuffer = gl.createBuffer();
        this.vertexIndexBuffer = gl.createBuffer();
        this.shaderProgram = initializeShader();
        this.loadTexture();
      }

      Sphere.prototype.loadTexture = function() {
        this.texture.image = new Image();
        this.texture.image.onload = (function(_this) {
          return function() {
            return handleLoadedTexture(_this.texture);
          };
        })(this);
        return this.texture.image.src = "images/moon.gif";
      };

      handleLoadedTexture = function(loadedTexture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, loadedTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, loadedTexture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
        return gl.bindTexture(gl.TEXTURE_2D, null);
      };

      initializeShader = function() {
        var shaderProgram;
        shaderProgram = ShaderProgramFactory.getInstance('sphere.vert', 'sphere.frag');
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram.program, 'uAmbientColor');
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram.program, 'uLightingDirection');
        shaderProgram.lightingColorUniform = gl.getUniformLocation(shaderProgram.program, 'uDirectionalColor');
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram.program, 'uSampler');
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram.program, 'uPMatrix');
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram.program, 'uMVMatrix');
        shaderProgram.normalMatrixUniform = gl.getUniformLocation(shaderProgram.program, 'uNormalMatrix');
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram.program, 'uUseLighting');
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram.program, 'aVertexPosition');
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        shaderProgram.textureCoordinateAttribute = gl.getAttribLocation(shaderProgram.program, 'aTextureCoord');
        gl.enableVertexAttribArray(shaderProgram.textureCoordinateAttribute);
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram.program, 'aVertexNormal');
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        return shaderProgram;
      };

      Sphere.prototype.initBuffers = function() {
        var cosPhi, cosTheta, first, indeces, latitude, longitude, normals, phi, second, sinPhi, sinTheta, textureCoordinates, theta, u, v, vertexPositions, x, y, z, _i, _j, _k, _l;
        normals = [];
        vertexPositions = [];
        textureCoordinates = [];
        for (latitude = _i = 0; 0 <= NUMBER_OF_LATITUDE_BANDS ? _i <= NUMBER_OF_LATITUDE_BANDS : _i >= NUMBER_OF_LATITUDE_BANDS; latitude = 0 <= NUMBER_OF_LATITUDE_BANDS ? ++_i : --_i) {
          theta = latitude * Math.PI / NUMBER_OF_LATITUDE_BANDS;
          sinTheta = Math.sin(theta);
          cosTheta = Math.cos(theta);
          for (longitude = _j = 0; 0 <= NUMBER_OF_LONGITUDE_BANDS ? _j <= NUMBER_OF_LONGITUDE_BANDS : _j >= NUMBER_OF_LONGITUDE_BANDS; longitude = 0 <= NUMBER_OF_LONGITUDE_BANDS ? ++_j : --_j) {
            phi = longitude * 2 * Math.PI / NUMBER_OF_LONGITUDE_BANDS;
            sinPhi = Math.sin(phi);
            cosPhi = Math.cos(phi);
            x = cosPhi * sinTheta;
            y = cosTheta;
            z = sinPhi * sinTheta;
            u = 1 - (longitude / NUMBER_OF_LONGITUDE_BANDS);
            v = 1 - (latitude / NUMBER_OF_LATITUDE_BANDS);
            normals.push(x);
            normals.push(y);
            normals.push(z);
            textureCoordinates.push(u);
            textureCoordinates.push(v);
            vertexPositions.push(RADIUS * x);
            vertexPositions.push(RADIUS * y);
            vertexPositions.push(RADIUS * z);
          }
        }
        indeces = [];
        for (latitude = _k = 0; 0 <= NUMBER_OF_LATITUDE_BANDS ? _k < NUMBER_OF_LATITUDE_BANDS : _k > NUMBER_OF_LATITUDE_BANDS; latitude = 0 <= NUMBER_OF_LATITUDE_BANDS ? ++_k : --_k) {
          for (longitude = _l = 0; 0 <= NUMBER_OF_LONGITUDE_BANDS ? _l < NUMBER_OF_LONGITUDE_BANDS : _l > NUMBER_OF_LONGITUDE_BANDS; longitude = 0 <= NUMBER_OF_LONGITUDE_BANDS ? ++_l : --_l) {
            first = (latitude * (NUMBER_OF_LONGITUDE_BANDS + 1)) + longitude;
            second = first + NUMBER_OF_LONGITUDE_BANDS + 1;
            indeces.push(first);
            indeces.push(second);
            indeces.push(first + 1);
            indeces.push(second);
            indeces.push(second + 1);
            indeces.push(first + 1);
          }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        this.vertexNormalBuffer.itemSize = 3;
        this.vertexNormalBuffer.numberOfItems = normals.length / 3;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordinateBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
        this.vertexTextureCoordinateBuffer.itemSize = 2;
        this.vertexTextureCoordinateBuffer.numberOfItems = textureCoordinates / 2;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions), gl.STATIC_DRAW);
        this.vertexPositionBuffer.itemSize = 3;
        this.vertexPositionBuffer.numberOfItems = vertexPositions / 3;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indeces), gl.STATIC_DRAW);
        this.vertexIndexBuffer.itemSize = 1;
        return this.vertexIndexBuffer.numberOfItems = indeces.length;
      };

      Sphere.prototype.render = function() {
        gl.enable(gl.DEPTH_TEST);
        gl.useProgram(this.shaderProgram.program);
        this.setLightingUniforms();
        this.setPosition();
        this.setTexture();
        this.setVertexAttributes();
        this.setMatrixUniforms();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        return gl.drawElements(gl.TRIANGLES, this.vertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
      };

      Sphere.prototype.setLightingUniforms = function() {
        var adjustedLightDirection;
        gl.uniform1i(this.shaderProgram.useLightingUniform, this.useLighting);
        if (!this.useLighting) {
          return;
        }
        gl.uniform3f(this.shaderProgram.ambientColorUniform, this.ambientLight.getRed(), this.ambientLight.getGreen(), this.ambientLight.getBlue());
        adjustedLightDirection = normalizeAndFlip([this.directionalLight.getX(), this.directionalLight.getY(), this.directionalLight.getZ()]);
        gl.uniform3fv(this.shaderProgram.lightingDirectionUniform, adjustedLightDirection);
        return gl.uniform3f(this.shaderProgram.lightingColorUniform, this.directionalLight.getRed(), this.directionalLight.getGreen(), this.directionalLight.getBlue());
      };

      Sphere.prototype.setPosition = function() {
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, [this.x, this.y, this.z]);
        return mat4.multiply(mvMatrix, this.rotationMatrix);
      };

      Sphere.prototype.setTexture = function() {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        return gl.uniform1i(this.shaderProgram.samplerUniform, 0);
      };

      normalizeAndFlip = function(baseVector) {
        var adjustedVector;
        adjustedVector = vec3.create();
        vec3.normalize(baseVector, adjustedVector);
        vec3.scale(adjustedVector, -1);
        return adjustedVector;
      };

      Sphere.prototype.setVertexAttributes = function() {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
        gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordinateBuffer);
        gl.vertexAttribPointer(this.shaderProgram.textureCoordinateAttribute, this.vertexTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
        return gl.vertexAttribPointer(this.shaderProgram.vertexNormalAttribute, this.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
      };

      Sphere.prototype.setMatrixUniforms = function() {
        var normalMatrix;
        gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, mvMatrix);
        normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        return gl.uniformMatrix3fv(this.shaderProgram.normalMatrixUniform, false, normalMatrix);
      };

      Sphere.prototype.animate = function() {};

      return Sphere;

    })();
    return {
      getInstance: function() {
        return new Sphere();
      }
    };
  });

}).call(this);
